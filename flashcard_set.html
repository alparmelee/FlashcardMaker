<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcards - CramCraft</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="stylesheet.css" />
</head>

<body class="flashcard-set-page">
    <nav class="top-nav">
        <div class="top-nav-inner">
            <div class="nav-logo"><a href="index.html">CramCraft</a></div>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="create.html">Create</a></li>
                <li><a href="user_dashboard.html">Dashboard</a></li>
                <li><a href="search_page.html">Search</a></li>
                <li><a href="about.html">About</a></li>
            </ul>
            <div class="user-status" style="display: none;">
                <span id="welcome-msg">Welcome, DemoUser!</span>
                <a href="#" id="logout-btn" class="logout-button">Logout</a>
            </div>
        </div>
    </nav>

    <div class="main-container">
        <header class="set-header">
            <h1>New Set</h1>
        </header>

        <div class="study-modes">
            <button class="mode-button active" id="mode-flashcards"><i class="fa-solid fa-clone"></i>
                Flashcards</button>
            <button class="mode-button" id="mode-quiz"><i class="fa-solid fa-pen-to-square"></i> Quiz</button>
            <button class="mode-button" id="mode-list"><i class="fa-solid fa-list-ul"></i> List</button>
            <button class="mode-button" id="mode-print"><i class="fa-solid fa-print"></i> Print</button>
        </div>

        <div id="flashcard-view">
            <div class="flashcard-viewer-container">
                <button class="card-nav-button" id="prev-card"><i class="fas fa-arrow-left"></i></button>
                <div class="flashcard" id="flashcard">
                    <div class="flashcard-inner">
                        <div class="flashcard-front" id="flashcard-front"></div>
                        <div class="flashcard-back" id="flashcard-back"></div>
                    </div>
                </div>
                <button class="card-nav-button" id="next-card"><i class="fas fa-arrow-right"></i></button>
            </div>
            <div class="card-navigation-wrapper">
                <p class="card-progress" id="card-progress"></p>
            </div>
        </div>

        <div id="quiz-view" class="hidden">
            <div class="quiz-mode-container">
                <h2 id="quiz-progress"></h2>
                <p class="quiz-question" id="quiz-question"></p>
                <div id="quiz-choices-container"></div>
            </div>
        </div>

        <div id="list-view" class="hidden">
            <div class="list-view-controls">
                <label for="category-filter">Sort by Category:</label>
                <select id="category-filter"></select>
            </div>
            <div class="term-list-container" id="term-list-container"></div>
        </div>

        <div class="creator-info">
            <img src="https://static.vecteezy.com/system/resources/previews/009/292/244/non_2x/default-avatar-icon-of-social-media-user-vector.jpg"
                alt="Creator's profile picture">
            <div class="details">
                <span>Created by</span>
                <strong id="creator-name"></strong>
            </div>
        </div>
    </div>

    <div id="print-view"></div>

    <script type="module">
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';
        const supabaseUrl = 'https://uxytxzliqxpinajccvbu.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV4eXR4emxpcXhwaW5hamNjdmJ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg1Nzg4MjgsImV4cCI6MjA2NDE1NDgyOH0.1RE6lzGdoj7kfaExaJrBUap9TwuQs5d3TxLarQaweb8';
        const supabase = createClient(supabaseUrl, supabaseKey, {});

        window.supabase = supabase; // Make supabase globally accessible

        document.addEventListener('DOMContentLoaded', async () => {
            const flashcardFront = document.getElementById("flashcard-front");
            const flashcardBack = document.getElementById("flashcard-back");
            const prevBtn = document.getElementById("prev-card");
            const nextBtn = document.getElementById("next-card");
            const welcomeMsg = document.getElementById("welcome-msg");
            const modePrintBtn = document.getElementById('mode-print');
            const printViewContainer = document.getElementById('print-view');
            const flashcard = document.getElementById('flashcard');
            const cardProgress = document.getElementById('card-progress');

            const modeFlashcardsBtn = document.getElementById('mode-flashcards');
            const modeQuizBtn = document.getElementById('mode-quiz');
            const modeListBtn = document.getElementById('mode-list');

            const flashcardView = document.getElementById('flashcard-view');
            const quizView = document.getElementById('quiz-view');
            const listView = document.getElementById('list-view');

            const quizProgress = document.getElementById('quiz-progress');
            const quizQuestion = document.getElementById('quiz-question');
            const quizChoicesContainer = document.getElementById('quiz-choices-container');

            const categoryFilter = document.getElementById('category-filter');
            const termListContainer = document.getElementById('term-list-container');

            let flashcards = [];
            let flashcardData = [];
            let currentIndex = 0;
            let isShowingFront = true; //
            let currentQuizIndex = 0; // Renamed from 'showFront' as it's not a boolean state here anymore.

            const urlParams = new URLSearchParams(window.location.search);
            const setId = urlParams.get('set_id');
            if (!setId) {
                alert("No set ID provided.");
                window.location.href = "user_dashboard.html";
                return;
            }

            const setTitleElement = document.querySelector('.set-header h1');

            try {
                const { data: setData, error: setError } = await supabase
                    .from('flashcard_sets')
                    .select('title')
                    .eq('id', setId)
                    .single();

                if (setError && setError.code !== 'PGRST116') { // PGRST116 means "No rows found"
                    console.error('Error fetching set title:', setError.message);
                    setTitleElement.textContent = 'Untitled Set';
                } else if (setData) {
                    setTitleElement.textContent = setData.title || 'Untitled Set';
                } else {
                    setTitleElement.textContent = 'Untitled Set';
                }
            } catch (error) {
                console.error('Unexpected error fetching set title:', error);
                setTitleElement.textContent = 'Untitled Set';
            }

            const sessionResult = await supabase.auth.getSession();
            const user = sessionResult.data.session?.user;

            if (user) {
                const { data: profile } = await supabase
                    .from("profiles")
                    .select("username")
                    .eq("user_id", user.id)
                    .single();

                const username = profile?.username || user.email || "User";
                welcomeMsg.textContent = `Welcome, ${username}!`;
                document.querySelector(".user-status").style.display = "block";
                document.getElementById('logout-btn').addEventListener('click', async (e) => {
                    e.preventDefault();
                    await supabase.auth.signOut();
                    window.location.href = 'login.html';
                });
            }

            const creatorNameElement = document.getElementById("creator-name");

            try {
                const { data: setMeta, error: setMetaError } = await supabase
                    .from('flashcard_sets')
                    .select('user_id')
                    .eq('id', setId)
                    .single();

                if (setMetaError && setMetaError.code !== 'PGRST116' || !setMeta?.user_id) {
                    console.error("Error fetching set creator ID:", setMetaError?.message);
                    creatorNameElement.textContent = "Unknown";
                } else if (setMeta?.user_id) {
                    const { data: profileData, error: profileError } = await supabase
                        .from("profiles")
                        .select("username")
                        .eq("user_id", setMeta.user_id)
                        .single();

                    if (profileError || !profileData?.username) {
                        console.error("Error fetching creator username:", profileError?.message);
                        creatorNameElement.textContent = "Unknown";
                    } else {
                        creatorNameElement.textContent = profileData.username;
                    }
                } else {
                    creatorNameElement.textContent = "Unknown";
                }
            } catch (e) {
                console.error("Unexpected error getting creator name:", e);
                creatorNameElement.textContent = "Unknown";
            }

            const { data, error } = await supabase
                .from("flashcards")
                .select("term, definition, category") // Make sure to select 'category' if it exists in your DB
                .eq("set_id", setId);

            if (error) {
                console.error("Error fetching flashcards:", error.message);
                flashcardFront.textContent = "Failed to load flashcards.";
                return;
            }

            flashcards = (data || []).filter(card => card.term?.trim() && card.definition?.trim());
            flashcardData = [...flashcards]; // Use this for Quiz/List views

            if (flashcardData.length === 0) {
                document.querySelector('.main-container').innerHTML = '<p>No flashcards found for this set.</p>';
                return;
            }

            // Function to dynamically adjust font size
            function adjustFontSize(element) {
                const parent = element.parentElement; // flashcard-front or flashcard-back
                let fontSize = 48; // Start with a large font size
                element.style.fontSize = `${fontSize}px`; // Apply initial font size
                element.style.whiteSpace = 'normal'; // Allow text to wrap initially

                // Reset overflow for accurate measurement
                element.style.overflow = 'visible';

                // Check if text overflows, and shrink if it does
                // Loop until text fits or min font size is reached
                while (
                    (element.scrollHeight > parent.clientHeight || element.scrollWidth > parent.clientWidth) &&
                    fontSize > 10
                ) {
                    fontSize -= 1; // Decrement by 1 for finer control
                    element.style.fontSize = `${fontSize}px`;
                }

                // If text still overflows at min font size, hide overflow
                if (fontSize <= 10 && (element.scrollHeight > parent.clientHeight || element.scrollWidth > parent.clientWidth)) {
                    element.style.overflow = 'auto'; // Or 'hidden' if you prefer
                } else {
                    element.style.overflow = 'visible'; // Reset if it fits
                }
            }

            function renderCard(index) {
    const card = flashcards[index];
    if (!card) {
        flashcardFront.textContent = "";
        flashcardBack.textContent = "";
        return;
    }

    // Set content for both sides
    flashcardFront.textContent = card.term;
    flashcardBack.textContent = card.definition;

    // Always show the front (term) when navigating to a new card
    flashcardFront.style.display = 'flex'; // Make front visible
    flashcardBack.style.display = 'none';  // Make back hidden
    isShowingFront = true; // Update our state variable to reflect this

    // Adjust font size for both front and back
    adjustFontSize(flashcardFront);
    adjustFontSize(flashcardBack);

    document.getElementById("card-progress").textContent =
        `Card ${currentIndex + 1} of ${flashcards.length}`;
}

             // ONLY TOGGLE THE 'FLIPPED' CLASS ON CARD CLICK
            document.getElementById("flashcard").addEventListener("click", () => {
    if (isShowingFront) {
        flashcardFront.style.display = 'none'; // Hide the front
        flashcardBack.style.display = 'flex';  // Show the back
    } else {
        flashcardFront.style.display = 'flex'; // Show the front
        flashcardBack.style.display = 'none';  // Hide the back
    }
    isShowingFront = !isShowingFront; // Toggle the state variable
});

            // --- DEBOUNCE UTILITY FUNCTION ---
            // This function ensures that `func` is only called once per `delay` milliseconds,
            // even if the event fires multiple times.
            function debounce(func, delay) {
                let timeout;
                return function(...args) {
                    const context = this;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            }

            // --- DEFINE DEBOUNCED NAVIGATION HANDLERS ---
            const debouncedNext = debounce(() => {
                if (currentIndex < flashcards.length - 1) {
                    currentIndex++;
                    console.log("Next Card - Current Index:", currentIndex); // For debugging
                    renderCard(currentIndex);
                }
            }, 200); // 200ms delay to prevent accidental double-clicks

            const debouncedPrev = debounce(() => {
                if (currentIndex > 0) {
                    currentIndex--;
                    console.log("Previous Card - Current Index:", currentIndex); // For debugging
                    renderCard(currentIndex);
                }
            }, 200); // 200ms delay to prevent accidental double-clicks

            // --- ATTACH ONLY THE DEBOUNCED LISTENERS TO THE BUTTONS ---
            nextBtn.addEventListener("click", debouncedNext);
            prevBtn.addEventListener("click", debouncedPrev);

            // --- REST OF YOUR FUNCTIONS (NO CHANGES HERE) ---
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            function switchView(activeView) {
                const views = { flashcard: flashcardView, quiz: quizView, list: listView };
                const buttons = { flashcard: modeFlashcardsBtn, quiz: modeQuizBtn, list: modeListBtn };
                for (const view in views) {
                    views[view].classList.add('hidden');
                    buttons[view].classList.remove('active');
                }
                views[activeView].classList.remove('hidden');
                buttons[activeView].classList.add('active');
                if (activeView === 'quiz') startQuiz();
                if (activeView === 'list') renderListView();
            }

            function populateCategoryFilter() {
                const categories = ['All', ...new Set(flashcardData.map(card => card.category).filter(Boolean))];
                categoryFilter.innerHTML = '';
                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    categoryFilter.appendChild(option);
                });
            }

            function renderListView(category = 'All') {
                termListContainer.innerHTML = '';
                const filteredData = category === 'All' ? flashcardData : flashcardData.filter(card => card.category === category);
                filteredData.forEach(card => {
                    const row = document.createElement('div');
                    row.className = 'term-row';
                    row.innerHTML = `<div class="term">${card.term}</div><div class="definition">${card.definition}</div>`;
                    termListContainer.appendChild(row);
                });
            }

            function startQuiz() {
                currentQuizIndex = 0;
                shuffleArray(flashcardData); // Shuffle flashcardData for quiz questions
                showQuizQuestion(currentQuizIndex);
            }

            function showQuizQuestion(index) {
                if (index >= flashcardData.length) {
                    quizQuestion.textContent = "Quiz Complete!";
                    quizProgress.textContent = "";
                    quizChoicesContainer.innerHTML = '';
                    return;
                }
                const currentCard = flashcardData[index];
                quizQuestion.textContent = `What is the definition of "${currentCard.term}"?`;
                quizProgress.textContent = `Question ${index + 1} of ${flashcardData.length}`;
                const correctAnswer = currentCard.definition;
                const incorrectAnswers = [];
                // Ensure there are enough unique incorrect answers
                const availableDefinitions = flashcardData.map(card => card.definition).filter(def => def !== correctAnswer);
                shuffleArray(availableDefinitions); // Shuffle available definitions
                while (incorrectAnswers.length < 3 && availableDefinitions.length > 0) {
                    const randomDefinition = availableDefinitions.shift(); // Take from shuffled array
                    if (!incorrectAnswers.includes(randomDefinition)) {
                        incorrectAnswers.push(randomDefinition);
                    }
                }

                const choices = shuffleArray([correctAnswer, ...incorrectAnswers]);
                quizChoicesContainer.innerHTML = '';
                choices.forEach(choice => {
                    const button = document.createElement('button');
                    button.className = 'choice-button';
                    button.textContent = choice;
                    button.addEventListener('click', handleChoiceClick);
                    quizChoicesContainer.appendChild(button);
                });
            }

            function handleChoiceClick(event) {
                const selectedButton = event.target;
                const chosenAnswer = selectedButton.textContent;
                const correctAnswer = flashcardData[currentQuizIndex].definition;
                const buttons = quizChoicesContainer.querySelectorAll('.choice-button');
                buttons.forEach(button => button.disabled = true);
                if (chosenAnswer === correctAnswer) {
                    selectedButton.classList.add('correct');
                } else {
                    selectedButton.classList.add('incorrect');
                    buttons.forEach(button => {
                        if (button.textContent === correctAnswer) {
                            button.classList.add('correct');
                        }
                    });
                }
                setTimeout(() => {
                    currentQuizIndex++;
                    showQuizQuestion(currentQuizIndex);
                }, 2500);
            }

            function prepareAndPrintAdvanced() {
                const CARDS_PER_PRINT_PAGE = 10;
                const dataToPrint = [...flashcardData];

                // Pad the data with empty slots
                while (dataToPrint.length % CARDS_PER_PRINT_PAGE !== 0) {
                    dataToPrint.push({ term: `(Empty Slot)`, definition: `(Empty Slot)` });
                }

                const printTotalPages = (dataToPrint.length / CARDS_PER_PRINT_PAGE) * 2;
                printViewContainer.innerHTML = '';

                for (let i = 0; i < printTotalPages; i++) {
                    const isTermPage = i % 2 === 0;
                    const setIndex = Math.floor(i / 2);
                    const startIdx = setIndex * CARDS_PER_PRINT_PAGE;

                    const printPageTitleElement = document.createElement('h3');
                    printPageTitleElement.className = 'print-page-title';
                    printPageTitleElement.textContent = `Page ${i + 1} / ${printTotalPages} - ${isTermPage ? 'Terms' : 'Definitions'} (Set ${setIndex + 1})`;
                    printViewContainer.appendChild(printPageTitleElement);

                    const grid = document.createElement('div');
                    grid.className = 'flashcard-grid';

                    for (let j = 0; j < CARDS_PER_PRINT_PAGE; j++) {
                        let indexToFetchDataFrom = startIdx + j;
                        if (indexToFetchDataFrom >= dataToPrint.length) break;

                        const itemToDisplay = dataToPrint[indexToFetchDataFrom];
                        const card = document.createElement('div');
                        card.className = 'card-item';

                        const originalItemIndex = indexToFetchDataFrom + 1;
                        const labelText = isTermPage ? `TERM ${originalItemIndex}` : `DEFINITION ${originalItemIndex}`;
                        const contentText = isTermPage ? itemToDisplay.term : itemToDisplay.definition;

                        card.innerHTML = `<span class="label">${labelText}</span>${contentText.replace(/\n/g, '<br>')}`;
                        grid.appendChild(card);
                    }
                    printViewContainer.appendChild(grid);
                }

                window.print();
            }

            // --- EVENT LISTENERS FOR MODE SWITCHING AND CATEGORY FILTER ---
            modeFlashcardsBtn.addEventListener('click', () => switchView('flashcard'));
            modeQuizBtn.addEventListener('click', () => switchView('quiz'));
            modeListBtn.addEventListener('click', () => switchView('list'));
            modePrintBtn.addEventListener('click', prepareAndPrintAdvanced);
            categoryFilter.addEventListener('change', (e) => renderListView(e.target.value));

            // Initial Load: Populate filter and render the first card
            populateCategoryFilter();
            renderCard(currentIndex);
        });
    </script>
</body>

</html>
